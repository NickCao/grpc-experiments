// Copyright 2024 The Jumpstarter Authors

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: proto/jumpstarter.proto

package grpc_experiments

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ForExporter_Register_FullMethodName      = "/jumpstarter.ForExporter/Register"
	ForExporter_ControlStream_FullMethodName = "/jumpstarter.ForExporter/ControlStream"
	ForExporter_Bye_FullMethodName           = "/jumpstarter.ForExporter/Bye"
	ForExporter_DataStream_FullMethodName    = "/jumpstarter.ForExporter/DataStream"
	ForExporter_EventStream_FullMethodName   = "/jumpstarter.ForExporter/EventStream"
)

// ForExporterClient is the client API for ForExporter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ForExporterClient interface {
	// Exporter registration
	Register(ctx context.Context, in *ExporterReport, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Server <-> Exporter command streams
	ControlStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_ControlStreamClient, error)
	// Exporter disconnection
	Bye(ctx context.Context, in *ExporterBye, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Messages for streaming drivers (audio/video/serial/other)
	DataStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_DataStreamClient, error)
	// Events from/to drivers
	EventStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_EventStreamClient, error)
}

type forExporterClient struct {
	cc grpc.ClientConnInterface
}

func NewForExporterClient(cc grpc.ClientConnInterface) ForExporterClient {
	return &forExporterClient{cc}
}

func (c *forExporterClient) Register(ctx context.Context, in *ExporterReport, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ForExporter_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forExporterClient) ControlStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_ControlStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ForExporter_ServiceDesc.Streams[0], ForExporter_ControlStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &forExporterControlStreamClient{stream}
	return x, nil
}

type ForExporter_ControlStreamClient interface {
	Send(*ClientResponse) error
	Recv() (*ServerCommand, error)
	grpc.ClientStream
}

type forExporterControlStreamClient struct {
	grpc.ClientStream
}

func (x *forExporterControlStreamClient) Send(m *ClientResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *forExporterControlStreamClient) Recv() (*ServerCommand, error) {
	m := new(ServerCommand)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *forExporterClient) Bye(ctx context.Context, in *ExporterBye, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ForExporter_Bye_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forExporterClient) DataStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_DataStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ForExporter_ServiceDesc.Streams[1], ForExporter_DataStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &forExporterDataStreamClient{stream}
	return x, nil
}

type ForExporter_DataStreamClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type forExporterDataStreamClient struct {
	grpc.ClientStream
}

func (x *forExporterDataStreamClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *forExporterDataStreamClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *forExporterClient) EventStream(ctx context.Context, opts ...grpc.CallOption) (ForExporter_EventStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ForExporter_ServiceDesc.Streams[2], ForExporter_EventStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &forExporterEventStreamClient{stream}
	return x, nil
}

type ForExporter_EventStreamClient interface {
	Send(*Event) error
	Recv() (*Event, error)
	grpc.ClientStream
}

type forExporterEventStreamClient struct {
	grpc.ClientStream
}

func (x *forExporterEventStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *forExporterEventStreamClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForExporterServer is the server API for ForExporter service.
// All implementations must embed UnimplementedForExporterServer
// for forward compatibility
type ForExporterServer interface {
	// Exporter registration
	Register(context.Context, *ExporterReport) (*emptypb.Empty, error)
	// Server <-> Exporter command streams
	ControlStream(ForExporter_ControlStreamServer) error
	// Exporter disconnection
	Bye(context.Context, *ExporterBye) (*emptypb.Empty, error)
	// Messages for streaming drivers (audio/video/serial/other)
	DataStream(ForExporter_DataStreamServer) error
	// Events from/to drivers
	EventStream(ForExporter_EventStreamServer) error
	mustEmbedUnimplementedForExporterServer()
}

// UnimplementedForExporterServer must be embedded to have forward compatible implementations.
type UnimplementedForExporterServer struct {
}

func (UnimplementedForExporterServer) Register(context.Context, *ExporterReport) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedForExporterServer) ControlStream(ForExporter_ControlStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ControlStream not implemented")
}
func (UnimplementedForExporterServer) Bye(context.Context, *ExporterBye) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bye not implemented")
}
func (UnimplementedForExporterServer) DataStream(ForExporter_DataStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DataStream not implemented")
}
func (UnimplementedForExporterServer) EventStream(ForExporter_EventStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EventStream not implemented")
}
func (UnimplementedForExporterServer) mustEmbedUnimplementedForExporterServer() {}

// UnsafeForExporterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForExporterServer will
// result in compilation errors.
type UnsafeForExporterServer interface {
	mustEmbedUnimplementedForExporterServer()
}

func RegisterForExporterServer(s grpc.ServiceRegistrar, srv ForExporterServer) {
	s.RegisterService(&ForExporter_ServiceDesc, srv)
}

func _ForExporter_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExporterReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForExporterServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForExporter_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForExporterServer).Register(ctx, req.(*ExporterReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForExporter_ControlStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ForExporterServer).ControlStream(&forExporterControlStreamServer{stream})
}

type ForExporter_ControlStreamServer interface {
	Send(*ServerCommand) error
	Recv() (*ClientResponse, error)
	grpc.ServerStream
}

type forExporterControlStreamServer struct {
	grpc.ServerStream
}

func (x *forExporterControlStreamServer) Send(m *ServerCommand) error {
	return x.ServerStream.SendMsg(m)
}

func (x *forExporterControlStreamServer) Recv() (*ClientResponse, error) {
	m := new(ClientResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ForExporter_Bye_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExporterBye)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForExporterServer).Bye(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForExporter_Bye_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForExporterServer).Bye(ctx, req.(*ExporterBye))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForExporter_DataStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ForExporterServer).DataStream(&forExporterDataStreamServer{stream})
}

type ForExporter_DataStreamServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type forExporterDataStreamServer struct {
	grpc.ServerStream
}

func (x *forExporterDataStreamServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *forExporterDataStreamServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ForExporter_EventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ForExporterServer).EventStream(&forExporterEventStreamServer{stream})
}

type ForExporter_EventStreamServer interface {
	Send(*Event) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type forExporterEventStreamServer struct {
	grpc.ServerStream
}

func (x *forExporterEventStreamServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func (x *forExporterEventStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForExporter_ServiceDesc is the grpc.ServiceDesc for ForExporter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ForExporter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jumpstarter.ForExporter",
	HandlerType: (*ForExporterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _ForExporter_Register_Handler,
		},
		{
			MethodName: "Bye",
			Handler:    _ForExporter_Bye_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ControlStream",
			Handler:       _ForExporter_ControlStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DataStream",
			Handler:       _ForExporter_DataStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "EventStream",
			Handler:       _ForExporter_EventStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/jumpstarter.proto",
}

const (
	ForClient_GetReport_FullMethodName     = "/jumpstarter.ForClient/GetReport"
	ForClient_ControlStream_FullMethodName = "/jumpstarter.ForClient/ControlStream"
	ForClient_DataStream_FullMethodName    = "/jumpstarter.ForClient/DataStream"
)

// ForClientClient is the client API for ForClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ForClientClient interface {
	// Exporter registration
	GetReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ExporterReport, error)
	// Server <-> Exporter command streams
	ControlStream(ctx context.Context, opts ...grpc.CallOption) (ForClient_ControlStreamClient, error)
	// Messages for streaming drivers (audio/video/serial/other)
	DataStream(ctx context.Context, opts ...grpc.CallOption) (ForClient_DataStreamClient, error)
}

type forClientClient struct {
	cc grpc.ClientConnInterface
}

func NewForClientClient(cc grpc.ClientConnInterface) ForClientClient {
	return &forClientClient{cc}
}

func (c *forClientClient) GetReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ExporterReport, error) {
	out := new(ExporterReport)
	err := c.cc.Invoke(ctx, ForClient_GetReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forClientClient) ControlStream(ctx context.Context, opts ...grpc.CallOption) (ForClient_ControlStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ForClient_ServiceDesc.Streams[0], ForClient_ControlStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &forClientControlStreamClient{stream}
	return x, nil
}

type ForClient_ControlStreamClient interface {
	Send(*ServerCommand) error
	Recv() (*ClientResponse, error)
	grpc.ClientStream
}

type forClientControlStreamClient struct {
	grpc.ClientStream
}

func (x *forClientControlStreamClient) Send(m *ServerCommand) error {
	return x.ClientStream.SendMsg(m)
}

func (x *forClientControlStreamClient) Recv() (*ClientResponse, error) {
	m := new(ClientResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *forClientClient) DataStream(ctx context.Context, opts ...grpc.CallOption) (ForClient_DataStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ForClient_ServiceDesc.Streams[1], ForClient_DataStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &forClientDataStreamClient{stream}
	return x, nil
}

type ForClient_DataStreamClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type forClientDataStreamClient struct {
	grpc.ClientStream
}

func (x *forClientDataStreamClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *forClientDataStreamClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForClientServer is the server API for ForClient service.
// All implementations must embed UnimplementedForClientServer
// for forward compatibility
type ForClientServer interface {
	// Exporter registration
	GetReport(context.Context, *emptypb.Empty) (*ExporterReport, error)
	// Server <-> Exporter command streams
	ControlStream(ForClient_ControlStreamServer) error
	// Messages for streaming drivers (audio/video/serial/other)
	DataStream(ForClient_DataStreamServer) error
	mustEmbedUnimplementedForClientServer()
}

// UnimplementedForClientServer must be embedded to have forward compatible implementations.
type UnimplementedForClientServer struct {
}

func (UnimplementedForClientServer) GetReport(context.Context, *emptypb.Empty) (*ExporterReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedForClientServer) ControlStream(ForClient_ControlStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ControlStream not implemented")
}
func (UnimplementedForClientServer) DataStream(ForClient_DataStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DataStream not implemented")
}
func (UnimplementedForClientServer) mustEmbedUnimplementedForClientServer() {}

// UnsafeForClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForClientServer will
// result in compilation errors.
type UnsafeForClientServer interface {
	mustEmbedUnimplementedForClientServer()
}

func RegisterForClientServer(s grpc.ServiceRegistrar, srv ForClientServer) {
	s.RegisterService(&ForClient_ServiceDesc, srv)
}

func _ForClient_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForClientServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForClient_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForClientServer).GetReport(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForClient_ControlStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ForClientServer).ControlStream(&forClientControlStreamServer{stream})
}

type ForClient_ControlStreamServer interface {
	Send(*ClientResponse) error
	Recv() (*ServerCommand, error)
	grpc.ServerStream
}

type forClientControlStreamServer struct {
	grpc.ServerStream
}

func (x *forClientControlStreamServer) Send(m *ClientResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *forClientControlStreamServer) Recv() (*ServerCommand, error) {
	m := new(ServerCommand)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ForClient_DataStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ForClientServer).DataStream(&forClientDataStreamServer{stream})
}

type ForClient_DataStreamServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type forClientDataStreamServer struct {
	grpc.ServerStream
}

func (x *forClientDataStreamServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *forClientDataStreamServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForClient_ServiceDesc is the grpc.ServiceDesc for ForClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ForClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jumpstarter.ForClient",
	HandlerType: (*ForClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReport",
			Handler:    _ForClient_GetReport_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ControlStream",
			Handler:       _ForClient_ControlStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DataStream",
			Handler:       _ForClient_DataStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/jumpstarter.proto",
}
